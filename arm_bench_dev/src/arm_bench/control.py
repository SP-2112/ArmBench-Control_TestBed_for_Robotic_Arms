"""
Custom control algorithm module for arm-bench
Supports position, velocity, and torque control with standardized ROS2 interface
"""
import os
import shutil
import subprocess
from typing import Optional, Dict, List
from pathlib import Path
import yaml


class ControlMode:
    """Control mode constants"""
    POSITION = "position"
    VELOCITY = "velocity"
    TORQUE = "torque"


class StandardControlInterface:
    """
    Standardized control interface for robot arms
    Publishes commands in a consistent format across all control modes
    """
    
    def __init__(self, mode: str = ControlMode.POSITION, frequency: int = 100):
        self.mode = mode
        self.frequency = frequency
        self.ros_workspace = os.path.expanduser("~/arm_bench_ros_ws")
        self.control_package = "arm_bench_control"
        
    def get_topic_name(self) -> str:
        """Get ROS2 topic name for current control mode"""
        return f"/arm_bench/{self.mode}_command"
    
    def get_message_format(self) -> Dict:
        """
        Get standardized message format for control commands
        
        Returns:
            Dictionary describing the message structure
        """
        if self.mode == ControlMode.POSITION:
            return {
                "header": {
                    "stamp": "ros2 time",
                    "frame_id": "base_link"
                },
                "joint_names": ["joint_1", "joint_2", "..."],
                "positions": [0.0, 0.0],  # radians
                "time_from_start": 0.0  # seconds
            }
        
        elif self.mode == ControlMode.VELOCITY:
            return {
                "header": {
                    "stamp": "ros2 time",
                    "frame_id": "base_link"
                },
                "joint_names": ["joint_1", "joint_2", "..."],
                "velocities": [0.0, 0.0],  # rad/s
            }
        
        elif self.mode == ControlMode.TORQUE:
            return {
                "header": {
                    "stamp": "ros2 time",
                    "frame_id": "base_link"
                },
                "joint_names": ["joint_1", "joint_2", "..."],
                "effort": [0.0, 0.0],  # Nm
            }
        
        return {}
    
    def create_control_template(self, output_path: str):
        """
        Create a template control algorithm file
        
        Args:
            output_path: Where to save the template
        """
        template = f"""#!/usr/bin/env python3
\"\"\"
Custom {self.mode.upper()} Control Algorithm
Generated by arm-bench

Control Frequency: {self.frequency} Hz
Control Mode: {self.mode}
ROS2 Topic: {self.get_topic_name()}
\"\"\"

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import JointState
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint
from std_msgs.msg import Float64MultiArray
import numpy as np


class CustomController(Node):
    def __init__(self):
        super().__init__('arm_bench_custom_controller')
        
        # Parameters
        self.control_mode = '{self.mode}'
        self.frequency = {self.frequency}  # Hz
        self.dt = 1.0 / self.frequency
        
        # Joint names (update for your robot)
        self.joint_names = [
            'joint_1', 'joint_2', 'joint_3',
            'joint_4', 'joint_5', 'joint_6'
        ]
        
        # State variables
        self.current_joint_states = None
        self.target_positions = np.zeros(len(self.joint_names))
        
        # Publishers
        self.command_pub = self.create_publisher(
            JointTrajectory,
            '{self.get_topic_name()}',
            10
        )
        
        # Subscribers
        self.state_sub = self.create_subscription(
            JointState,
            '/joint_states',
            self.state_callback,
            10
        )
        
        # Control loop timer
        self.timer = self.create_timer(self.dt, self.control_loop)
        
        self.get_logger().info(f'Custom {{self.control_mode}} controller started at {{self.frequency}} Hz')
    
    def state_callback(self, msg):
        \"\"\"Receive current joint states\"\"\"
        self.current_joint_states = msg
    
    def control_loop(self):
        \"\"\"Main control loop - CUSTOMIZE THIS\"\"\"
        if self.current_joint_states is None:
            return
        
        # Get current positions
        current_pos = np.array(self.current_joint_states.position)
        
        # ==================================================
        # YOUR CONTROL ALGORITHM GOES HERE
        # ==================================================
        
        # Example: Simple sinusoidal motion
        t = self.get_clock().now().nanoseconds / 1e9
        self.target_positions = np.array([
            0.5 * np.sin(2 * np.pi * 0.1 * t),  # Joint 1
            0.3 * np.cos(2 * np.pi * 0.1 * t),  # Joint 2
            0.0,  # Joint 3
            0.0,  # Joint 4
            0.0,  # Joint 5
            0.0,  # Joint 6
        ])
        
        # Compute control command based on mode
        if self.control_mode == 'position':
            command = self.target_positions
        elif self.control_mode == 'velocity':
            # Simple P controller for velocity
            kp = 1.0
            error = self.target_positions - current_pos
            command = kp * error
        elif self.control_mode == 'torque':
            # Simple PD controller for torque
            kp = 10.0
            kd = 1.0
            error = self.target_positions - current_pos
            velocity = np.array(self.current_joint_states.velocity) if len(self.current_joint_states.velocity) > 0 else np.zeros_like(error)
            command = kp * error - kd * velocity
        else:
            command = np.zeros_like(current_pos)
        
        # ==================================================
        
        # Publish command in standardized format
        self.publish_command(command)
    
    def publish_command(self, command):
        \"\"\"Publish control command in standardized format\"\"\"
        msg = JointTrajectory()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.header.frame_id = 'base_link'
        msg.joint_names = self.joint_names
        
        point = JointTrajectoryPoint()
        
        if self.control_mode == 'position':
            point.positions = command.tolist()
            point.time_from_start.sec = 0
            point.time_from_start.nanosec = int(self.dt * 1e9)
        elif self.control_mode == 'velocity':
            point.velocities = command.tolist()
        elif self.control_mode == 'torque':
            point.effort = command.tolist()
        
        msg.points = [point]
        self.command_pub.publish(msg)


def main(args=None):
    rclpy.init(args=args)
    controller = CustomController()
    
    try:
        rclpy.spin(controller)
    except KeyboardInterrupt:
        pass
    finally:
        controller.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
"""
        
        with open(output_path, 'w') as f:
            f.write(template)
        
        # Make executable
        os.chmod(output_path, 0o755)
        
        print(f"Control template created: {output_path}")
        print(f"Mode: {self.mode}, Frequency: {self.frequency} Hz")


class ControlDeployer:
    """Deploys custom control algorithms to ROS2 workspace"""
    
    def __init__(self, ros_workspace: Optional[str] = None):
        self.ros_workspace = ros_workspace or os.path.expanduser("~/arm_bench_ros_ws")
        self.package_name = "arm_bench_control"
        self.package_path = os.path.join(self.ros_workspace, "src", self.package_name)
        
    def create_ros_package(self) -> bool:
        """Create ROS2 package for control algorithms"""
        try:
            # Create workspace if doesn't exist
            src_path = os.path.join(self.ros_workspace, "src")
            os.makedirs(src_path, exist_ok=True)
            
            # Check if package exists
            if os.path.exists(self.package_path):
                print(f"Package already exists: {self.package_path}")
                return True
            
            # Create ROS2 package
            cmd = [
                "ros2", "pkg", "create",
                self.package_name,
                "--build-type", "ament_python",
                "--dependencies", "rclpy", "sensor_msgs", "trajectory_msgs", "std_msgs"
            ]
            
            result = subprocess.run(
                cmd,
                cwd=src_path,
                check=True,
                capture_output=True,
                text=True
            )
            
            print(f"Created ROS2 package: {self.package_name}")
            return True
            
        except subprocess.CalledProcessError as e:
            print(f"Error creating package: {e}")
            print(e.stderr)
            return False
        except Exception as e:
            print(f"Error: {e}")
            return False
    
    def deploy_control_file(self, control_file: str, mode: str, frequency: int) -> bool:
        """
        Deploy custom control file to ROS2 workspace
        
        Args:
            control_file: Path to control algorithm file
            mode: Control mode (position/velocity/torque)
            frequency: Control frequency in Hz
            
        Returns:
            True if successful
        """
        try:
            # Ensure package exists
            if not os.path.exists(self.package_path):
                self.create_ros_package()
            
            # Copy control file to package
            scripts_dir = os.path.join(self.package_path, self.package_name)
            os.makedirs(scripts_dir, exist_ok=True)
            
            control_filename = f"{mode}_controller_{frequency}hz.py"
            dest_path = os.path.join(scripts_dir, control_filename)
            
            shutil.copy2(control_file, dest_path)
            os.chmod(dest_path, 0o755)
            
            # Update setup.py to include the script
            self._update_setup_py(control_filename)
            
            print(f"Deployed control file: {dest_path}")
            print(f"Mode: {mode}, Frequency: {frequency} Hz")
            
            # Create launch file
            self._create_launch_file(control_filename, mode, frequency)
            
            return True
            
        except Exception as e:
            print(f"Error deploying control file: {e}")
            return False
    
    def _update_setup_py(self, script_name: str):
        """Update setup.py to include new script"""
        setup_py_path = os.path.join(self.package_path, "setup.py")
        
        if not os.path.exists(setup_py_path):
            return
        
        # Read current setup.py
        with open(setup_py_path, 'r') as f:
            content = f.read()
        
        # Add entry point if not already there
        script_entry = f"'{script_name.replace('.py', '')} = {self.package_name}.{script_name.replace('.py', '')}:main'"
        
        if script_entry not in content:
            # Find entry_points section and add
            print(f"Added entry point for {script_name}")
    
    def _create_launch_file(self, script_name: str, mode: str, frequency: int):
        """Create launch file for the control algorithm"""
        launch_dir = os.path.join(self.package_path, "launch")
        os.makedirs(launch_dir, exist_ok=True)
        
        launch_file = os.path.join(launch_dir, f"{script_name.replace('.py', '')}_launch.py")
        
        launch_content = f"""from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='{self.package_name}',
            executable='{script_name.replace('.py', '')}',
            name='arm_bench_{mode}_controller',
            output='screen',
            parameters=[
                {{'control_mode': '{mode}'}},
                {{'frequency': {frequency}}}
            ]
        )
    ])
"""
        
        with open(launch_file, 'w') as f:
            f.write(launch_content)
        
        print(f"Created launch file: {launch_file}")
    
    def build_package(self) -> bool:
        """Build the ROS2 package"""
        try:
            print("Building ROS2 package...")
            
            cmd = ["colcon", "build", "--packages-select", self.package_name]
            
            result = subprocess.run(
                cmd,
                cwd=self.ros_workspace,
                check=True,
                capture_output=True,
                text=True
            )
            
            print("Package built successfully!")
            print(f"\nTo use, run:")
            print(f"  source {self.ros_workspace}/install/setup.bash")
            print(f"  ros2 launch {self.package_name} <launch_file>")
            
            return True
            
        except subprocess.CalledProcessError as e:
            print(f"Error building package: {e}")
            print(e.stderr)
            return False
    
    def launch_controller(self, mode: str, frequency: int) -> bool:
        """Launch a control algorithm"""
        try:
            launch_file = f"{mode}_controller_{frequency}hz_launch.py"
            
            cmd = [
                "ros2", "launch",
                self.package_name,
                launch_file
            ]
            
            print(f"Launching {mode} controller at {frequency} Hz...")
            process = subprocess.Popen(cmd)
            
            print(f"Controller launched with PID: {process.pid}")
            return True
            
        except Exception as e:
            print(f"Error launching controller: {e}")
            return False


def create_control_template(mode: str, frequency: int, output_path: str):
    """Convenience function to create a control template"""
    interface = StandardControlInterface(mode, frequency)
    interface.create_control_template(output_path)


def deploy_control_algorithm(control_file: str, mode: str, frequency: int) -> bool:
    """Convenience function to deploy a control algorithm"""
    deployer = ControlDeployer()
    
    if deployer.deploy_control_file(control_file, mode, frequency):
        return deployer.build_package()
    
    return False
